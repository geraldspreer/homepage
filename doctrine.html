---
layout: doctrine
title: Doctrine
permalink: /doctrine/
---

    <section>
      <h1 style="margin-bottom: 0px">Die Rails-Doktrin</h1>
      <p style="margin-top: 0"><small style="color: grey">Von David Heinemeier Hansson im Januar 2016</small></p>

      <figure class="right">
        <img src="/images/doctrine.png" alt="The Rails Doctrine">
      </figure>

      <p>Der phänomenale Aufstieg von Ruby on Rails war größtenteils auf neuartige Technologie und Timing zurückzuführen. Aber die technologischen Vorteile schwinden mit der Zeit, und ein gutes Timing hält Bewegungen auf lange Sicht nicht allein aufrecht. Daher ist eine umfassendere Erklärung erforderlich, wie Rails weiterhin nicht nur relevant bleibt, sondern auch seine Wirkung und Community steigert. Ich schlage vor, dass der dauerhafte Wegbereiter seine kontroverse Doktrin war und bleibt.</p>

      <p>Diese Doktrin hat sich im letzten Jahrzehnt weiterentwickelt, aber die meisten ihrer stärksten Säulen sind auch die Gründungspfeiler. Ich erhebe keinen Anspruch auf die grundsätzliche Originalität dieser Ideen. Die Hauptleistung von Rails bestand darin, einen starken Stamm um eine breite Palette ketzerischer Gedanken über die Natur des Programmierens und der Programmierer zu vereinen und zu kultivieren.</p>

      <p>Mit all dem Lärm folgen hier die neun wichtigsten Säulen der Rails-Doktrin, wie sie von Ihnen wirklich wahrgenommen werden:</p>

      <p>
        <ol>
          <li><a href="#optimize-for-programmer-happiness">Optimierem um die Freude des Programmierers zu vollenden</a></li>
          <li><a href="#convention-over-configuration">Konvention über Konfiguration</a></li>
          <li><a href="#omakase">Das Menü ist Omakase</a></li>
          <li><a href="#no-one-paradigm">Kein Paradigma</a></li>
          <li><a href="#beautiful-code">Loben Sie bewundernswerten Code</a></li>
          <li><a href="#provide-sharp-knives">Stellen Sie scharfe Messer bereit</a></li>
          <li><a href="#integrated-systems">Wertintegrierte Systeme</a></li>
          <li><a href="#progress-over-stability">Fortschritt über Stabilität</a></li>
          <li><a href="#big-tent">Schieben Sie ein großes Zelt hoch</a></li>
        </ol>
      </p>

      <h2 id="optimize-for-programmer-happiness">Optimieren Sie für das Glück des Programmierers</h2>

      <p>Ohne Ruby gäbe es Rails nicht, daher ist es nur passend, dass die erste Lehrsäule direkt von der Kernmotivation für die Erstellung von Ruby abgehoben wird.</p>

      <p>Rubys ursprüngliche Häresie bestand in der Tat darin, das Glück des Programmierers auf ein Podest zu stellen. Vor vielen anderen konkurrierenden und berechtigten Bedenken, die zuvor Programmiersprachen und Ökosysteme vorangetrieben hatten.</p>

      <p>Wo Python sich rühmen könnte, dass es „einen und vorzugsweise nur einen Weg gibt, etwas zu tun“, genoss Ruby Ausdruckskraft und Subtilität. Während Java sich dafür einsetzte, Programmierer gewaltsam vor sich selbst zu schützen, nahm Ruby ein Set scharfer Messer in das Begrüßungskit auf. Während Smalltalk eine Reinheit der Nachrichtenübermittlung bohrte, sammelte Ruby Schlüsselwörter und Konstrukte mit einem fast gefräßigen Appetit.</p>

      <p>Ruby war anders, weil es verschiedene Dinge schätzte. Und die meisten dieser Dinge dienten dieser Sehnsucht nach Programmiererglück. Ein Streben, das nicht nur den meisten anderen Programmierumgebungen widersprach, sondern auch der allgemeinen Wahrnehmung, was ein Programmierer war und wie er sich verhalten sollte.</p>

      <p>Ruby musste die Gefühle der Programmierer nicht nur erkennen, sondern auch berücksichtigen und steigern. Ob sie von Unzulänglichkeit, Laune oder Freude sind. Matz übersprang Implementierungshürden von erstaunlicher Komplexität, damit die Maschine ihren menschlichen Mitverschwörer anlächelte und ihm schmeichelte. Ruby ist voller optischer Täuschungen, bei denen das, was für unser geistiges Auge einfach, klar und schön erscheint, tatsächlich ein akrobatisches Durcheinander von Drähten unter der Haube ist. Diese Entscheidungen waren nicht frei (fragen Sie die JRuby-Crew nach dem Versuch, diese magische Spieluhr rückzuentwickeln!), Und genau deshalb sind sie so lobenswert.</p>

      <p>Es war diese Hingabe an eine alternative Vision für Programmierer und Programmierer, die meine Liebesbeziehung zu Ruby besiegelte. Es war nicht nur einfach zu bedienen, es war nicht nur die Ästhetik von Blöcken, es war keine einzige technische Errungenschaft. Es war eine Vision. Eine Gegenkultur. Ein Ort, an dem die Außenseiter der bestehenden professionellen Programmierform zu Gleichgesinnten gehören und sich mit ihnen verbinden können.</p>

      <p>I’ve described this discovery of Ruby in the past as finding a magical glove that just fit my brain perfectly. Better than I had ever imagined any glove could ever fit. But it was even more than that. It was the event that marked my own personal transition from ‘doing programming because I needed programs’ to ‘doing programming because I fell in love with it as a mode of intellectual exercise and expression’. It was finding a <a href="http://www.amazon.com/Flow-Harper-Perennial-Modern-Classics-ebook/dp/B000W94FE6/">fountain of flow</a> and being able to turn it on at will. For anyone familiar with Csikszentmihalyi’s work, the impact of this is hard to overstate.</p>

      <p>I’m not exaggerating when I say that Ruby transformed me and set the course for my life’s work. So deep was the revelation. It imbued me with a calling to do missionary work in service of Matz’s creation. To help spread this profound creation and its benefits.</p>

      <p>Jetzt kann ich mir vorstellen, dass die meisten von Ihnen ungläubig den Kopf schütteln. Ich beschuldige dich nicht. Wenn mir jemand die Erfahrung oben beschrieben hätte, als ich noch unter dem Paradigma „Programmieren ist nur ein Werkzeug“ lebte, hätte auch ich den Kopf geschüttelt. Und dann hätte ich wahrscheinlich über den übertriebenen Gebrauch religiöser Sprache gelacht. Aber damit dies ein wahrheitsgemäßer Bericht ist, muss er auch ehrlich sein, auch wenn dies einige oder sogar die meisten abschreckt.</p>

      <p>Was bedeutete das für Rails und wie leitet dieses Prinzip seine Entwicklung weiter? Um das zu beantworten, finde ich es lehrreich, ein anderes Prinzip zu betrachten, das in den frühen Tagen oft zur Beschreibung von Ruby verwendet wurde: Das Prinzip der geringsten Überraschung. Ruby sollte sich so verhalten, wie Sie es erwarten würden. Dies ist im Gegensatz zu Python leicht zu beschreiben:</p>

      <p>
        <code><pre>
    $ irb
    irb(main):001:0> exit
    $ irb
    irb(main):001:0> quit

    $ python
    >>> exit
    Use exit() or Ctrl-D (i.e. EOF) to exit</pre></code>
      </p>

      <p>Ruby akzeptiert sowohl das Beenden als auch das Beenden, um dem offensichtlichen Wunsch des Programmierers Rechnung zu tragen, seine interaktive Konsole zu beenden. Python hingegen weist den Programmierer pedantisch an, wie er die angeforderten Aktionen ordnungsgemäß ausführen soll, obwohl er offensichtlich weiß, was gemeint ist (da die Fehlermeldung angezeigt wird). Das ist ein ziemlich klares, wenn auch kleines Beispiel für PoLS.</p>

      <p>Der Grund, warum PoLS bei der Ruby-Community in Ungnade fiel, war, dass dieses Prinzip von Natur aus subjektiv ist. Am wenigsten überraschend für wen? Nun, zu Matz. Und Menschen, die genauso überrascht sind wie er. Als die Ruby-Community wuchs und der Anteil der Menschen, die von anderen Dingen als Matz überrascht waren, mitwuchs, wurde dies zu einer Quelle fruchtlosen Fahrradabwurfs auf den Mailinglisten. Das Prinzip trat also in den Hintergrund, damit nicht mehr Debatten darüber geführt werden, ob Person X von Verhalten Y überrascht wurde oder nicht.</p>

      <p>Was hat das mit Rails zu tun? Nun, Rails wurde nach einem ähnlichen Prinzip wie das Prinzip der geringsten Überraschung (To Matz) entwickelt. Das Prinzip des größeren Lächelns (von DHH), das genau das ist, was es verspricht: APIs, die mit großer Aufmerksamkeit entwickelt wurden und auf alles achten, was mich zum Lächeln bringen würde. Wenn ich es so schreibe, klingt das fast komisch narzisstisch, und selbst ich finde es schwierig, gegen diesen ersten Eindruck zu argumentieren.</p>

      <p>Aber so etwas wie Ruby oder Rails zu kreieren, ist zumindest zu Beginn ein zutiefst narzisstisches Unterfangen. Beide Projekte entsprangen einem einzigartigen Schöpfer. Aber vielleicht projiziere ich hier meine eigenen Motivationen auf Matz, also lassen Sie mich den Umfang meiner Proklamation auf das beschränken, was ich weiß: Ich habe Rails für mich erstellt. Um mich in erster Linie zum Lächeln zu bringen. Sein Nutzen war in hohem Maße seiner Fähigkeit unterworfen, mich mein Leben mehr genießen zu lassen. Um meine tägliche Arbeit an Streitanforderungen und Anfragen nach Webinformationssystemen zu bereichern.</p>

      <p>Wie Matz habe ich mich manchmal albern bemüht, meinem Prinzip zu dienen. Ein Beispiel ist der Inflector, eine Klasse, die gerade genug von den Mustern und Unregelmäßigkeiten der englischen Sprache versteht, um eine Personenklasse einer Personentabelle zuzuordnen, Analyse zu Analysen und einfach Kommentar zu Kommentaren. Dieses Verhalten wird jetzt als unbestrittenes Element von Rails akzeptiert, aber die kontroversen Feuer wüteten in den frühen Tagen, als wir die Doktrin und ihre Bedeutung noch zusammenführten, mit großer Intensität.</p>

      <p>Ein weiteres Beispiel, das weniger Implementierungsaufwand erforderte, aber fast genauso viel Bestürzung auslöste: Array # second bis #fifth (und #forty_two für eine gute Trolling-Maßnahme). Diese Alias-Accessoren waren zutiefst beleidigend für einen sehr lautstarken Wahlkreis, der das Aufblähen (und gegen Ende der Zivilisation, zum guten Teil) von etwas, das genauso gut geschrieben werden könnte wie Array # [1], Array # [2] (und Array [ 41]).</p>

      <p>Aber beide Entscheidungen bringen mich bis heute zum Lächeln. Ich genieße es, Leute zu schreiben. Drittens in einem Testfall oder auf der Konsole. Nein, das ist nicht logisch. Es ist nicht effizient. Es kann sogar pathologisch sein. Aber es bringt mich weiterhin zum Lächeln, erfüllt das Prinzip und bereichert mein Leben. Dies trägt dazu bei, meine fortgesetzte Beschäftigung mit Rails nach 12 Dienstjahren zu rechtfertigen.</p>

      <p>Im Gegensatz zur Optimierung der Leistung ist es schwierig, die Optimierung der Leistung zu messen. Dies macht es zu einem fast von Natur aus unwissenschaftlichen Unterfangen, das es für einige weniger wichtig, wenn nicht geradezu frustrierend macht. Programmierer lernen, das Messbare zu argumentieren und zu erobern. Das, was klare Schlussfolgerungen hat und wo A kategorisch als besser als B gezeigt werden kann.</p>

      <p>Während das Streben nach Glück auf Mikroebene schwer zu messen ist, ist es auf Makroebene viel klarer zu beobachten. Die Ruby on Rails-Community ist voll von Leuten, die genau wegen dieser Verfolgung hier sind. Sie rühmen sich eines besseren und erfüllteren Arbeitslebens. In dieser Ansammlung von Emotionen ist der Sieg klar.</p>

      <p>Wir schließen daraus: Die Optimierung für das Glück ist vielleicht der prägendste Schlüssel zu Ruby on Rails. Dies soll auch in Zukunft so bleiben.</p>

      <h2 id="convention-over-configuration">Konvention über Konfiguration</h2>

      <p>One of the early productivity mottos of Rails went: “You’re not a beautiful and unique snowflake”. It postulated that by giving up vain individuality, you can leapfrog the toils of mundane decisions, and make faster progress in areas that really matter.</p>

      <p>Wen interessiert es, in welchem Format Ihre Datenbankprimärschlüssel beschrieben werden? Ist es wirklich wichtig, ob es sich um &quot;id&quot;, &quot;postId&quot;, &quot;posts_id&quot; oder &quot;pid&quot; handelt? Ist dies eine Entscheidung, die einer wiederholten Überlegung wert ist? Nein.</p>

      <p>Ein Teil der Mission von Rails ist es, die Machete im dichten und ständig wachsenden Dschungel wiederkehrender Entscheidungen zu schwingen, denen Entwickler gegenüberstehen, die Informationssysteme für das Web erstellen. Es gibt Tausende solcher Entscheidungen, die nur einmal getroffen werden müssen, und wenn jemand anderes dies für Sie tun kann, umso besser.</p>

      <p>Die Übertragung der Konfiguration auf die Konvention befreit uns nicht nur von Überlegungen, sondern bietet auch ein üppiges Feld, um tiefere Abstraktionen zu entwickeln. Wenn wir uns auf eine Personenklassenzuordnung zur Personentabelle verlassen können, können wir dieselbe Beugung verwenden, um eine als has_many: people deklarierte Zuordnung zuzuordnen, um nach einer Personenklasse zu suchen. Die Kraft guter Konventionen besteht darin, dass sie sich über ein breites Anwendungsspektrum auszahlen.</p>

      <p>But beyond the productivity gains for experts, conventions also lower the barriers of entry for beginners. There are so many conventions in Rails that a beginner doesn’t even need to know about, but can just benefit from in ignorance. It’s possible to create great applications without knowing why everything is the way it is.</p>

      <p>That’s not possible if your framework is merely a thick textbook and your new application a blank piece of paper. It takes immense effort to even figure out where and how to start. Half the battle of getting going is finding a thread to pull.</p>

      <p>The same goes even when you understand how all the pieces go together. When there’s an obvious next step for every change, we can scoot through the many parts of an application that is the same or very similar to all the other applications that went before it. A place for everything and everything in its place. Constraints liberate even the most able minds.</p>

      <p>As with anything, though, the power of convention isn’t without peril. When Rails makes it so trivial to do so much, it is easy to think every aspect of an application can be formed by precut templates. But most applications worth building have some elements that are unique in some way. It may only be 5% or 1%, but it’s there.</p>

      <p>The hard part is knowing when to stray from convention. When are the deviating particulars grave enough to warrant an excursion? I contend that most impulses to be a beautiful and unique snowflake are ill considered, and that the cost of going off the Rails is under appreciated, but just enough of them won’t be that you need to examine all of them carefully.</p>


      <h2 id="omakase">The menu is omakase</h2>

      <p>How do you know what to order in a restaurant when you don’t know what’s good? Well, if you let the chef choose, you can probably assume a good meal, even before you know what “good” is. That is omakase. A way to eat well that requires you neither be an expert in the cuisine nor blessed with blind luck at picking in the dark.

      <p>For programming, the benefits of this practice, letting others assemble your stack, is similar to those we derive from Convention over Configuration, but at a higher level. Where CoC is occupied with how we best use individual frameworks, omakase is concerned with <em>which</em> frameworks, and how they fit together.

      <p>This is at odds with the revered programming tradition of presenting available tools as individual choices, and to bestow the individual programmer privilege (and burden!) of deciding.

      <p>You’ve surely heard, and probably nodded to, “use the best tool for the job”. It sounds so elementary as to be beyond debate, but being able to pick the “best tool” depends on a foundation that allows “best” to be determined with confidence. This is much harder than it seems.

      <p>It is a problem similar to that of the diner in a restaurant. And like picking each course in an eight-set meal, picking each individual library or framework is not a job done in isolation. The objective in both cases is to consider the whole evening or system.

      <p>So with Rails we decided to diminish one good, a programmer’s individual privilege to choose each tool in their box, for a greater one: A better tool box for all. The dividends are legion:

      <p><ol><li><b>There’s safety in numbers:</b> When most people are using Rails in the same default ways, we have a shared experience. This common ground makes it much easier to teach and help people. It lays a foundation for debate on approach. We all watched the same show last night at 7, so we can talk about it the next day. It fosters a stronger sense of community.</li>

      <li><b>People are perfecting the same, basic tool box:</b> As a full-stack framework, Rails has a lot of moving parts, and how those work together is as important as what they do in isolation. Much of the pain in software comes not from the individual components, but from their interaction. When we all work on alleviating shared pain from components that are configured and fail in the same ways, then we all experience less pain.</li>

      <li><b>Substitutions are still possible, but not required:</b> While Rails is an omakase stack, it still allows you to replace certain frameworks or libraries with alternatives. It just doesn’t require you to. Which means you can delay those decisions until you’ve developed a clear, personal palette that may prefer the occasional difference.</li>
      </ol></p>

      <p>Because even the most learned and skilled programmers who come to and stay in Rails aren’t likely opposed to all matters of the menu. (If they were, they probably wouldn’t have stuck with Rails.) So they pick their substitutions with diligence, and then go on to enjoy the rest of the curated, shared stack alongside everyone else.</p>


      <h2 id="no-one-paradigm">No one paradigm</h2>

      <p>There’s a strong emotional appeal to picking a single central idea and following it to the logical conclusion as your architectural underpinning. There’s a purity in such discipline, so it’s clear why programmers are naturally attracted to this bright light.</p>

      <p>Rails isn’t like that. It isn’t a single, perfect cut of cloth. It’s a quilt. A composite of many different ideas and even paradigms. Many that would usually be seen in conflict, if contrasted alone and one by one. But that’s not what we’re trying to do. It isn’t a single championship of superior ideas where a sole winner must be declared.</p>

      <p>Take the templates we build the view in our Rails MVC pie with. By default, all the helpers that allow us to extract code from these templates are just a big pot of functions! It’s a single namespace even. Oh the shock and the horror, it’s like PHP soup!</p>

      <p>But I contend that PHP had it right when it came to presenting individual functions that rarely needed to interact, as is the case with much abstraction in view templates. And for this purpose, the single namespace, the big pot of methods, is not only a reasonable choice, but a great one.</p>

      <p>This doesn’t mean we don’t occasionally want to reach for something more object-oriented when building views. The concept of Presenters, where we wrap many methods that are interdependent with each other and the data below it, can occasionally be the perfect antidote to a soup of methods turned sour by dependencies. But it’s generally proved to be the rare rather than common fit.</p>

      <p>In comparison, we generally treat the model in our MVC layer cake as the prime bastion of object-oriented goodness. Finding just the right names for objects, increasing the coherence, and lowering the coupling is the fun of domain modeling. It’s a very different layer from the view, so we take a different approach.</p>

      <p>But even here we don’t subscribe to single-paradigm dogma. Rails concerns, the specialization of Ruby’s mixins, are often used to give the individual models a very wide surface area. This fits well with the Active Record pattern by giving the concerned methods direct access to the data and storage they interact with.</p>

      <p>Even the very foundation of the Active Record framework offends some purists. We’re mixing the logic needed for interfacing with the database directly with the business domain and logic. Such conflation of boundaries! Yes, because it proved to be the practical way to skin a web-app cat that virtually always talks to a database of some sort to persist the state of the domain model.</p>

      <p>To be so ideologically flexible is what enables Rails to tackle such a wide array of problems. Most individual paradigms do very well within a certain slice of the problem space, but become awkward or rigid when applied beyond its natural sphere of comfort. By applying many overlapping paradigms, we cover the flanks and guard the rear. The final framework is far stronger and more capable than any individual paradigm would have allowed it to be.</p>

      <p>Now, the cost of this polyamorous relationship with the many paradigms of programming is conceptual overhead. It’s not enough to just know object-oriented programming to have a good time with Rails. It’s preferable to be well served with procedural and functional experiences as well.</p>

      <p>This applies to the many sub-languages of Rails as well. We don’t try to shield you that much from having to learn, say, JavaScript for the view or SQL for the occasional complicated query. At least not to reach the peaks of possibilities.</p>

      <p>The way to alleviate some of that learning burden is to simply just make it easy to get started, make something of real value, before you understand every single aspect of the framework. We have a rush to Hello World for this reason. Your table already prepared and an appetizer served.</p>

      <p>The thinking is that by giving something of real value early, we’ll encourage the practitioners of Rails to level-up quickly. Accept their journey of learning as a joy, not an obstacle.</p>


      <h2 id="beautiful-code">Exalt beautiful code</h2>

      <p>We write code not just to be understood by the computer or other programmers, but to bask in the warm glow of beauty. Aesthetically pleasing code is a value unto itself and should be pursued with vigor. That doesn’t mean that beautiful code always trumps other concerns, but it should have a full seat at the table of priorities.</p>

      <p>So what is beautiful code? In Ruby, it’s often somewhere at the intersection between native Ruby idioms and the power of a custom domain-specific language. It’s a fuzzy line, but one well worth trying to dance.</p>

      <p>Here’s a simple example from Active Record:</p>

      <p>
        <code><pre>
    class Project < ApplicationRecord
      belongs_to :account
      has_many :participants, class_name: 'Person'
      validates_presence_of :name
    end</pre></code>
      </p>

      <p>This looks like DSL, but it’s really just a class definition with three class-method calls that take symbols and options. There’s nothing fancy here. But it sure is pretty. It sure is simple. It gives an immense amount of power and flexibility from those few declarations.</p>

      <p>Part of the beauty comes from these calls honoring the previous principles, like Convention over Configuration. When we call belongs_to :account, we’re assuming that the foreign key is called account_id and that it lives in the projects table. When we have to designate the class_name of Person to the role of the participants association, we require just that class name definition. From it we’ll derive, again, the foreign keys and other configuration points.</p>

      <p>Here’s another example from the database migrations system:</p>

      <p>
        <code><pre>
    class CreateAccounts < ActiveRecord::Migration
      def change
        create_table :accounts do |t|
          t.integer :queenbee_id
          t.timestamps
        end
      end
    end</pre></code>
      </p>

      <p>This is the essence of framework power. The programmer declares a class according to certain convention, like a ActiveRecord::Migration subclass that implements #change, and the framework can do all the plumbing that goes around that, and know this is the method to call.</p>

      <p>This leaves the programmer with very little code to write. In the case of migrations, not only will this allow a call to rails db:migrate to upgrade the database to add this new table, it’ll also allow it to go the other way of dropping this table with another call. This is very different from a programmer making all this happen and stitching the workflow together from libraries they call themselves.</p>

      <p>Sometimes beautiful code is more subtle, though. It’s less about making something as short or powerful as possible, but more about making the rhythm of the declaration flow.</p>

      <p>These two statements do the same:</p>

      <p>
        <code><pre>
    if people.include? person
      …

    if person.in? people</pre></code>
      </p>

      <p>But the flow and focus is subtlety different. In the first statement, the focus is on the collection. That’s our subject. In the second statement, the subject is clearly the person. There’s not much between the two statements in length, but I’ll contend that the second is far more beautiful and likely to make me smile when used in a spot where the condition is about the person.</p>

      <h2 id="provide-sharp-knives">Provide sharp knives</h2>

      <p>Ruby includes a lot of sharp knives in its drawer of features. Not by accident, but by design. The most famous is monkey patching: The power to change existing classes and methods.</p>

      <p>This power has frequently been derided as simply too much for mere mortal programmers to handle. People from more restrictive environments used to imagine all sorts of calamities that would doom Ruby because of the immense trust the language showed its speakers with this feature.</p>

      <p>If you can change anything, what is there to stop you from overwriting String#capitalize so that “something bold”.capitalize returns “Something Bold” rather than “Something bold”? That might work in your local application, but then break all sorts of auxiliary code that depend on the original implementation.</p>

      <p>Nothing, is the answer. There’s nothing programmatically in Ruby to stop you using its sharp knives to cut ties with reason. We enforce such good senses by convention, by nudges, and through education. Not by banning sharp knives from the kitchen and insisting everyone use spoons to slice tomatoes.</p>

      <p>Because the flip side of monkey patching is the power to do such feats of wonder as 2.days.ago (which returns a date two days back from the current). Now you might well think that’s a bad trade. That you’d rather lose 2.days.ago if it means preventing programmers from overwriting String#capitalize. If that’s your position, Ruby is probably not for you.</p>

      <p>Yet it’d be hard — even for people who would give up such freedom for some security — to argue that the power to change core classes and methods has doomed Ruby as a language. On the contrary, the language flourished exactly because it offered a different and radical perspective on the role of the programmer: That they could be trusted with sharp knives.</p>

      <p>And not only trusted, but taught in the ways to use such capable tools. That we could elevate the entire profession by assuming most programmers would want to become better programmers, capable of wielding sharp knives without cutting off their fingers. That’s an incredibly aspirational idea, and one that runs counter to a lot of programmer’s intuition about other programmers.</p>

      <p>Because it’s always about other programmers when the value of sharp knives is contested. I’ve yet to hear a single programmer put up their hand and say “I can’t trust myself with this power, please take it away from me!”. It’s always “I think other programmers would abuse this”. That line of paternalism has never appealed to me.</p>

      <p>That brings us to Rails. The knives provided by the framework are not nearly as sharp as those offered with the language, but some are still plenty keen to cut. We will make no apologies for offering such tools as part of the kit. In fact, we should celebrate having enough faith in the aspirations of our fellow programmers to dare trust them.</p>

      <p>Plenty of features in Rails have been contested over time as being “too much freedom”. But one example that’s currently in vogue is <a href="https://github.com/rails/rails/blob/master/activesupport/lib/active_support/concern.rb">the feature of concerns</a>. This is a thin layer of syntactic sugar around Ruby’s built-in feature of modules and is designed to allow a single class to encapsulate multiple related but independently understood concerns (hence the name).</p>

      <p>The charge is that concerns provide programmers prone to bloat their objects with a whole new set of drawers to stuff their clutter in. And that’s true. Concerns can indeed be used like that.</p>

      <p>But the grand fallacy is thinking that by <i>not</i> providing a feature like concerns, which when used by even mildly capable hands allows an eloquent partial separation of concepts, we’d put programmers on the path to architectural bliss. If you can’t be trusted to keep the kitchen sink out of your overstuffed concerns, you’re probably not going to end up with a shining beacon of elegance otherwise.</p>

      <p>Programmers who haven’t learned to wield sharp knifes just aren’t going to make meringues yet. Operative word here: Yet. I believe that every programmer has a path, if not a right, to become fully capable Ruby and Rails programmers. And by capable, I mean knowledgeable enough to know when and how, accordingly to their context, they should use the different and sometimes dangerous tools in the drawers.</p>

      <p>That does not abdicate a responsibility to help get them there. The language and the framework should be patient tutors willing to help and guide anyone to experthood. While recognizing that the only reliable course there goes through the land of mistakes: Tools used wrong, a bit of blood, sweat, and perhaps even some tears. There simply is no other way.</p>

      <p>Ruby on Rails is an environment for chefs and those who wish to become chefs. You might start out doing the dishes, but you can work your way up to running the kitchen. Don’t let anyone tell you that you can’t be trusted with the best tool in the trade as part of that journey.</p>

      <h2 id="integrated-systems">Value integrated systems</h2>

      <p>Rails can be used in many contexts, but its first love is the making of integrated systems: Majestic monoliths! A whole system that addresses an entire problem. This means Rails is concerned  with everything from the front-end JavaScript needed to make live updates to how the database is migrated from one version to another in production.</p>

      <p>That’s a very broad scope, as we’ve discussed, but no broader than to be realistic to understand for a single person. Rails specifically seeks to equip generalist individuals to make these full systems. Its purpose is not to segregate specialists into small niches and then require whole teams of such in order to build anything of enduring value.</p>

      <p>It is this focus on empowering the individual that points to the integrated system. It’s in the integrated system we can cut out many needless abstractions, reduce the duplication between layers (like templates on both the server and the client), and, above all, avoid distributing our system before we absolutely, positively have to.</p>

      <p>Much of the complication in systems development comes from introducing new boundaries between the elements that restrict how you make calls between A and B. Method calls between objects is far simpler than remote procedure calls between microservices. There’s a whole new world of hurt in failure states, latency issues, and dependency update schedules that await those who venture into the lair of distribution.</p>

      <p>Sometimes this distribution is simply necessary. If you want to create an API to your web application that other people can call over HTTP, well, then you just have to suck it up and deal with many of these issues (although handling requests inbound rather than sending them outbound is much easier – your downtime is someone else’s failure state!). But that’s at least a limited amount of damage inflicted on your own personal development experience.</p>

      <p>What’s worse is when systems are prematurely disintegrated and broken into services or, even worse, microservices. This drive frequently starts from the misconception that if you want a Modern Internet Application, you’ll simply have to build the systems many times over: Once on the server side, once on the JavaScript MVC client-side, once for each of the native mobile applications, and so forth. This is not a law of nature, it needn’t be so.</p>

      <p>It’s entirely possible to share large chunks of the entire application across multiple apps and accesses. To use the same controllers and views for the desktop web as for embedded in native mobile apps. To centralize as much as possible within that glorious, majestic monolith: The integrated system.</p>

      <p>All this without giving up much if anything in terms of speed, user experience, or other attributes that falsely draw developers to premature distribution.</p>

      <p>That’s the have-most-of-it-all we seek: All the power of individually tuned and distributed applications with the ease-of-use and understanding of a single, integrated system.</p>


      <h2 id="progress-over-stability">Progress over stability</h2>

      <p>When systems have been around for more than a decade, like Rails has, their natural tendency is towards ossification. There are a million reasons why every change might be an issue for someone, somewhere who depended on past behavior. And fair reasons those are too, for the individual.</p>

      <p>But if we listen too closely to the voices of conservatism, we’ll never see what’s on the other side. We have to dare occasionally break and change how things are to evolve and grow. It is this evolution that’ll keep Rails fit for survival and prosperity in the decade(s?) to come.</p>

      <p>This is all easy to understand in theory, but much harder to swallow in practice. Especially when it’s your application that breaks from a backwards-incompatible change in a major version of Rails. It’s at those times we need to remember this value, that we cherish progress over stability, to give us the strength to debug the busted, figure it out, and move with the times.</p>

      <p>That’s not a license to inflict needless or excessive hurt willy nilly. The Great Rails Migration of 2.x to 3 still lingers in the scar tissue of many who were around for that. It was a tough one. A serious upheaval that left many behind in 2.x land for a long time, some soured beyond convincing. But, in the grand scheme of things, it was still worth it.</p>

      <p>Those are the hard bargains we have to continue to make. Is Rails going to be better off in five years for the changes we make today? Is Rails going to be better off for adopting another problem domain, like job queuing or WebSockets, in years to come? If yes, then let’s suck it up and do the work.</p>

      <p>This work isn’t just something that needs to happen in Rails itself, but also in the larger Ruby community. Rails should be at the frontier of helping Ruby’s progress by driving its constituents to adopt later versions faster. </p>

      <p>We’ve done very well at this so far. From when I started, we’ve moved through Ruby 1.6, 1.8, 1.9, 2.0, 2.1, 2.2, 2.3, 2.4, 2.5 and now onto 2.6. Lots of major changes along the way, but Rails was there to have Ruby’s back, and help everyone get with the program faster. That’s in part the privilege and obligation Rails serves as the major popularizer of Ruby.</p>

      <p>This too is true for the auxiliary tools of the chain. Bundler was once a controversial idea, but through Rails' insistence that it be a cornerstone of a shared future, it’s today just taken for granted. The same is true for things like the asset pipeline and Spring, the persistent command process. All three of these went through, or are still going through, growing pains, but the obviousness of their value in the long term helped us push through that.</p>

      <p>Progress is ultimately mostly about people and their willingness to push change. This is why there are no lifetime seats in groups like <a href="/community#core">Rails Core</a> or <a href="/community#committers">Rails Committers</a>. Both groups are for those who are actively working on making progress for the framework. For some, their stake in such progress may last just a few years, and we will forever be grateful for their service, and for others it may last decades.</p>

      <p>Likewise, it’s why it’s so important for us to continue to welcome and encourage new members of the community. We need fresh blood and fresh ideas to make better progress.</p>


      <h2 id="big-tent">Push up a big tent</h2>

      <p>With so many controversial ideas to its credit, Rails could quickly become an insular group of ideological hermits, if we required everyone to exhibit complete deference to all tenets, all the time. So we don’t!</p>

      <p>We need disagreement. We need dialects. We need diversity of thought and people. It’s in this melting pot of ideas we’ll get the best commons for all to share. Lots of people chipping in their two cents, in code or considered argument.</p>

      <p>So while this doctrine has described an idealized form, the everyday reality is much more nuanced (and interesting). Rails is capable of supporting such a large community under one tent exactly because there are so few if any litmus tests. </p>

      <p>The continued success of RSpec, a DSL for testing I’ve often expressed grave discontent with, is perfect proof. I can rant until I’m blue in the face of why I don’t think it’s the way to go, and it can still blossom and prosper. That point is the far more important one!</p>

      <p>The same is true for the advent of Rails as an API. While my personal focus and dedication is to the integrated system that includes the view, there’s undoubtedly room for Rails to do well with people who do want to distribute their clients and servers upfront. We should embrace this inasmuch as it can coexist as a secondary mission, and I believe it surely can.</p>

      <p>Having a big tent doesn’t mean trying to be all things to all people, though. It just means you welcome all people to your party, and allow them to bring their own drinks. We need to lose none of our soul or values by offering others to join us, and we may well learn how to mix a new delicious drink or two.</p>

      <p>This doesn’t come for free. It requires work to be welcoming. Especially if your goal isn’t just to attract more people who are just like the ones who are already part of the community. Lowering the barriers to entry is work we should always take seriously.</p>

      <p>You never know when the next person who starts just fixing a misspelling in the documentation ends up implementing the next great feature. But you stand a chance to find out if you smile and say thank you for whatever small contribution that gets the motivation flowing.</p>
    </section>
